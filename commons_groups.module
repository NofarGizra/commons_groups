<?php
/**
 * @file
 * Code for the Commons Groups feature.
 */

include_once 'commons_groups.features.inc';

/**
 * Implements hook_entity_view().
 */
function commons_groups_entity_view($entity, $type, $view_mode, $langcode) {
  // Set a breadcrumb for nodes in groups. We currently assume that
  // nodes are groups.
  if ($view_mode == 'full' && !empty($entity->og_group_ref[LANGUAGE_NONE][0]['target_id']) && $type != 'user') {
    $breadcrumb = array();
    $breadcrumb[] = l(t('Home'), NULL);
    $breadcrumb[] = l(t('Groups'), 'groups');
    $group = node_load($entity->og_group_ref[LANGUAGE_NONE][0]['target_id']);
    if (node_access('view', $group)) {
      $breadcrumb[] = l($group->title, 'node/' . $group->nid);
    }
    drupal_set_breadcrumb($breadcrumb);
  }
}

/**
 * Implements hook_menu().
 */
function commons_groups_menu() {
  $items = array();

  $items['request-trust/%user/%/%'] = array(
    'page callback' => 'commons_groups_request_trust',
    'page arguments' => array(1, 3),
    'access callback' => 'commons_groups_request_trust_access',
    'access arguments' => array(1,2),
    'type' => MENU_CALLBACK,
  );

  $items['un-trust/%user/%/%'] = array(
    'page callback' => 'commons_groups_un_trust',
    'page arguments' => array(1, 3),
    'access callback' => 'commons_groups_un_trust_access',
    'access arguments' => array(1,2),
    'type' => MENU_CALLBACK,
  );

  $items['approve-trust/%entity_object/%'] = array(
    'load arguments' => array('og_membership'),
    'page callback' => 'commons_groups_approve_trust',
    'page arguments' => array(1),
    'access callback' => 'commons_groups_approve_trust_access',
    'access arguments' => array(1, 2),
    'type' => MENU_CALLBACK,
  );

  $items['ignore-trust/%entity_object/%'] = array(
    'load arguments' => array('og_membership'),
    'page callback' => 'commons_groups_ignore_trust',
    'page arguments' => array(1),
    'access callback' => 'commons_groups_ignore_trust_access',
    'access arguments' => array(1, 2),
    'type' => MENU_CALLBACK,
  );

  $items['contacts/messages/popup/%user'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commons_groups_messages_popup', 3),
    'access callback' => 'commons_groups_privatemsg_write_access',
    'access arguments' => array(2),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function commons_groups_menu_alter(&$items) {
  // Provide a more informative title.
  if (isset($items['node/%/group'])) {
    $items['node/%/group']['title'] = t('Administer group');
  }

  $items['messages/new']['access callback'] = 'commons_groups_privatemsg_write_access';
  $items['messages/new']['access arguments'] = array(2);
}

/**
 * Implements hook_admin_paths().
 */
function commons_groups_admin_paths() {
  $paths = array(
    'contacts/messages/popup/*' => TRUE,
  );

  return $paths;
}

/**
 * Implements hook_block_info().
 */
function commons_groups_block_info() {
   $blocks['commons_groups_create_group'] = array(
    'info' => t('"Create a group" call to action'),
    'cache' => DRUPAL_NO_CACHE,
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function commons_groups_block_view() {
  $block['subject'] = '';
  if (node_access('create', 'group')) {
    $block['content'] = l(t('Create a group'), 'node/add/group');
  }
  else {
    $block['content'] = '';
  }
  return $block;
}

/**
 * Implements hook_default_og_membership_type().
 */
function commons_groups_default_og_membership_type() {
  $items = array();
  $items['trusted_contacts'] = entity_import('og_membership_type', '{
    "name" : "trusted_contacts",
    "description" : "Trusted Contacts",
    "rdf_mapping" : []
  }');
  return $items;
}

/**
 * Implements hook_features_pipe_alter().
 *
 */
function commons_groups_features_pipe_alter(&$pipe, $data, $export) {
  // Prevent Commons Groups related fields from being piped in features
  // when a content type includes those fields.
  if (!empty($pipe['field_instance'])) {
    foreach ($pipe['field_instance'] as $delta => $value) {
      $args = explode('-', $value);
      $field_name = $args[2];
      if ($field_name == 'og_group_ref') {
        unset($pipe['field_instance'][$delta]);
      }
    }
  }
  if (!empty($pipe['field_base'])) {
    foreach ($pipe['field_base'] as $delta => $value) {
      if ($delta == 'og_group_ref') {
        unset($pipe['field_base'][$delta]);
      }
    }
  }
}

/**
 * Implements hook_commons_entity_integration().
 */
function commons_groups_commons_entity_integration() {
  return array(
    'node' => array(
      'group' => array(
        'is_group_content' => FALSE,
        'exclude_commons_follow' => TRUE,
      ),
    ),
  );
}

function commons_groups_group_contributors_count_topics($group) {

  // Format the count of contributors.
  $output = '';
  $view = views_get_view('commons_contributors_group');
  if (!empty($view)) {
    $view->set_display('panel_pane_1');
    $view->set_arguments(array($group->nid));
    $view->get_total_rows = TRUE;
    $view->execute();
    // If there are no contributors with avatars, return an empty string
    // rather than displaying '0 contributors'.
    if (empty($view->total_rows)) {
      return '';
    }
    $contributors_count = $view->total_rows;
    $output .= l(t('@contributors_count @contributors', array('@contributors_count' => $contributors_count, '@contributors' => format_plural($contributors_count, 'contributor', 'contributors'))), 'node/' . $group->nid . '/contributors');
  }
  // Format the list of topics:
  if (!empty($group->field_topics[LANGUAGE_NONE])) {
    foreach ($group->field_topics[LANGUAGE_NONE] as $item) {
      $tids[] = $item['tid'];
    }
    $topics = taxonomy_term_load_multiple($tids);
    $topics_text = ' discussing the @topics ';
    $t_args = array('@topics' => format_plural(count($topics), 'topic', 'topics'));
    foreach ($topics as $topic) {
      $topics_text .= '!topic-' . $topic->tid;
      if ($topic == end($topics)) {
        $topics_text .= '.';
      }
      else {
        $topics_text .= ', ';
      }
      $t_args['!topic-' . $topic->tid] = l(t($topic->name), 'taxonomy/term/' . $topic->tid);
    }
   $output .= t($topics_text, $t_args);
  }
  return $output;
}

/**
 * Implement hook_module_implements_alter().
 *
 * Set commons_Groups form alter to happen after views bulk operations.
 */
function commons_groups_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'form_alter') {
    $group = $implementations['commons_groups'];
    unset($implementations['commons_groups']);
    $implementations['commons_groups'] = $group;
  }
}

/**
 * Implements hook_form_alter().
 */
function commons_groups_form_alter(&$form, &$form_state, $form_id) {
  if($form_id == 'views_exposed_form' && strstr($form['#id'], 'views-exposed-form-commons-groups-directory')) {
    $form['groups-keys']['#attributes'] = array(
        'placeholder' => t('Separate keywords with commas'),
      );
  }
  if((strstr($form_id, 'views_form_commons_group_moderation_page'))) {
    $form['select']['action::views_bulk_operations_delete_item']['#weight'] = 9;
  }
  if ($form_id == 'group_node_form' && is_null($form['nid']['#value'])) {
    $form['actions']['submit']['#submit'][] = 'commons_groups_group_submission_message';
  }
  // Redirect the user back to the group homepage after submitting
  // a node within a group.
  if (isset($form['#node']) && substr($form_id, -10) == '_node_form') {
    // Set a human-friendly page title.
    if (empty($form['#node']->nid)) {
      $types = node_type_get_types();
      $type = $form['#node']->type;
      // Use 'a' or 'an' appropriately.
      $vowels = array('a', 'e', 'i', 'o', 'u');
      $verb = strtolower(in_array($type[0], $vowels)) ? 'Create an' : 'Create a';
      drupal_set_title(t("$verb @name", array('@name' => $types[$type]->name)), PASS_THROUGH);
    }
    // Customizations to the node form for entitites that are group content.
    $group_content_entity_types = commons_groups_get_group_content_entity_types();
    if (isset($group_content_entity_types['node'][$form['#node']->type])) {
      $form['actions']['submit']['#submit'][] = 'commons_groups_node_in_group_submit';
    }
  }
  if (in_array($form_id, array('og_ui_admin_global_permissions', 'og_ui_admin_permissions'))) {
    $group_content_entity_types = commons_groups_get_group_content_entity_types();
    if (!empty($group_content_entity_types)) {
      // @TODO: Improve this message to be more specific and/or
      // reflect these changes in the checkboxes.
      $message = 'In addition to the permissions listed here, the Commons Groups module grants non-group members the ability to post content into groups where content in the group is public.';
      drupal_set_message(t($message), 'warning');
    }
  }
}

/**
 * Submit handler; Called if the form is for a node enabled as group content.
 */
function commons_groups_node_in_group_submit(&$form, &$form_state) {
  if (isset($form_state['values']['og_group_ref'][LANGUAGE_NONE][0])) {
    $group = $form_state['values']['og_group_ref'][LANGUAGE_NONE][0]['target_id'];
    $form_state['redirect'] = 'node/' . $group;
  }
}

/**
* Implements hook_system_info_alter().
*/
function commons_groups_system_info_alter(&$info, $file, $type) {
  // Commons Groups dynamically adds the og_group_ref field to
  // content types that request it by altering the
  // commons_groups_entity_types variable.
  // We must add a corresponding line for each field instance
  // to commons_groups.info so that Features is aware of the instance
  // and can sucessfully revert the field_instance component back
  // to its default state.
  if ($file->name == 'commons_groups') {
    $group_content_entity_types = commons_groups_get_group_content_entity_types();
    if (!empty($group_content_entity_types)) {
      foreach ($group_content_entity_types as $entity_type => $bundles) {
        foreach(array_keys($bundles) as $bundle) {
          $info['features']['field_instance'][] = "$entity_type-$bundle-og_group_ref";
        }
      }
    }
  }
}

/**
 * Implements hook_default_message_type_alter().
 */
function commons_groups_default_message_type_alter(&$defaults) {
  foreach (array('commons_activity_streams_comment_created', 'commons_activity_streams_node_created') as $name) {
    if (!empty($defaults[$name])) {
      $defaults[$name]->message_text[LANGUAGE_NONE][2] = commons_groups_message_partial_default();
    }
  }
}


/**
* Implements hook_og_user_access_alter().
*/
function commons_groups_og_user_access_alter(&$temp_perm, $context) {
  // Grant access to non-group members to be able to post into groups
  // where the group node is public and content is public within the group.
  $commons_groups_entity_types = commons_groups_get_group_content_entity_types();
  $group_content_restricted = (bool) (isset($context['group']->group_content_access[LANGUAGE_NONE][0]['value']) && $context['group']->group_content_access[LANGUAGE_NONE][0]['value'] == 2);
  // @TODO: Consider using a static here.
  $user_is_member = (bool)og_is_member('node', $context['group']->nid, 'user', $context['account']);
  foreach ($commons_groups_entity_types['node'] as $type => $options) {
    // We do a literal user_access() check on the create permission here
    // because we can't call node_access() OR og_user_access without causing recursion.
    // The code flow is:
    // node_access()>og_node_access()=>og_user_access_entity=>og_user_access=>
    // og_user_access_alter()=>commons_groups_og_user_access_alter().
    // See also: http://drupal.org/node/1910874.

    // In most cases users who don't have access to post content should already be false. But just in case they aren't, we'll set the permission here.
    if ($context['string'] == "create $type content" && !user_access("create $type content", $context['account'])) {
      $temp_perm["create $type content"] = FALSE;
      return;
    }

    // If a group is not restricted, or the user is a member, and the user can create content of a certain type, let them post temporarily
    if ($context['string'] == "create $type content" && (!$group_content_restricted || $user_is_member) && user_access("create $type content", $context['account'])) {
      $temp_perm["create $type content"] = TRUE;
      return;
    }
  }
}


/**
 * Implements of hook_token_info().
 */
function commons_groups_token_info() {
  $types = array();
  $tokens = array();

  // Commons Groups tokens.
  $types['commons-groups'] = array(
    'name' => t('Commons Groups'),
    'description' => t('Tokens related to the Groups functionality in Drupal Commons.'),
    'needs-data' => 'node',
  );
  $tokens['commons-groups']['in-groups-text'] = array(
    'name' => t('"In groups" text'),
    'description' => t('The text (starting with "in the groups") indicating which groups a peice of content belongs to.'),
  );
  $tokens['node']['commons-groups-group-contributors-count-topics'] = array(
    'name' => t('Commons Groups: Group contributor count and topics'),
    'description' => t('Displays text showing the number of contributors and the topics associated with a group node.'),
  );
  return array(
    'types' => $types,
    'tokens' => $tokens,
  );
}

/**
 * Implements hook_tokens().
 */
function commons_groups_tokens($type, $tokens, $data = array(), $options = array()) {
  $replacements = array();
  if ($type == 'node' && !empty($data['node'])) {
    $group = $data['node'];

    foreach ($tokens as $name => $original) {
      if ($name == 'commons-groups-group-contributors-count-topics') {
        $replacements[$original] = commons_groups_group_contributors_count_topics($group);
        return $replacements;
      }
    }
  }
  if ($type == 'commons-groups') {
    if (!empty($tokens['in-groups-text']))  {
      // Build a list of groups associated with this message.
      $text = '';
      $target_nids = array();
      $related_groups = array();
      $related_gids = array();

      // First, build an array of target nodes associated with the message.
      foreach ($data['message']->field_target_nodes[LANGUAGE_NONE] as $key => $value) {
        $target_nids[] = $value['target_id'];
      }
      // If there are no target nodes, the in-groups-text token should be empty.
      if (empty($target_nids)) {
        $replacements['[commons-groups:in-groups-text]'] = $text;
        return $replacements;
      }
      // Build a list of groups associated with the target nodes.
      // For now, we assume that the group type is node.
      foreach ($target_nids as $key => $nid) {
        $og_memberships_this_target = og_get_entity_groups('node', $nid);
        if (!empty($og_memberships_this_target['node'])) {
          $og_memberships_this_target = $og_memberships_this_target['node'];
          foreach ($og_memberships_this_target as $membership_id => $gid) {
            $related_gids[] = $gid;
          }
        }
      }
      // If no groups are associated with any of the targett nodes,
      // then we have no "in the groups" text.
      if (empty($related_gids)) {
        $replacements['[commons-groups:in-groups-text]'] = '';
        return $replacements;
      }

      $related_groups = entity_load('node', $related_gids);
      // Key the array of groups in a predictable way.
      $related_groups = array_values($related_groups);
      // Generate the appropriate text depending on the number of groups
      // associated with the message:

      // In 1 group: "in the x group"
      if (count($related_groups) == 1) {
        $text = t(' in the !group group', array('!group' => l($related_groups[0]->title, 'node/' . $related_groups[0]->nid))) ;
        $replacements['[commons-groups:in-groups-text]'] = $text;
      }

      // In 2 groups: "in the x and y groups"
      if (count($related_groups) == 2) {
        $text = t(' in the !group-0 and !group-1 groups', array('!group-0' => l($related_groups[0]->title, 'node/' . $related_groups[0]->nid), '!group-1' => l($related_groups[1]->title, 'node/' . $related_groups[1]->nid)));
      }

      // In more than 2 groups: "in the x, y and z groups"
      if (count($related_groups) > 2) {
        // Separate the last group.
        $last_group = array_pop($related_groups);
        $text = ' in the ';
        // Prepare tokens for t() for each of the other groups.
        foreach ($related_groups as $key => $this_group) {
          $text .= "!group-$key, ";
          $t_args["!group-$key"] = l($this_group->title, 'node/' . $this_group->nid);
        }
        // Prepare the last group token.
        $text .= " and !group-$last_group->nid groups.";
        $t_args["!group-$last_group->nid"] = l($last_group->title, 'node/' . $last_group->nid);
        // Prepare the full text with all of the groups and their tokens:
        $text = t($text, $t_args);
      }
      $replacements['[commons-groups:in-groups-text]'] = $text;
      return $replacements;
    }
  }
}

function commons_groups_message_partial_default() {
  $partial = array(
    'value' => '[commons-groups:in-groups-text]',
    'format' => 'full_html',
    'safe_value' => '[commons-groups:in-groups-text]',
  );
  return $partial;
}

function commons_groups_group_submission_message($form, &$form_state) {
  if ($form_state['values']['status'] !== 1) {
    drupal_set_message(t('Thanks for your group submission! This group has entered the moderation queue and will be reviewed shortly.'));
  }
}

/**
* Default value function for the og_group_ref reference field.
* This function is assigned to the field with the default_value_function
* property defined in our instances of the og_group_ref field,
* which takes place in commons_groups_field_definition().
*/
function commons_groups_entityreference_default_value($entity_type, $entity, $field, $instance, $langcode) {

  $items = array();
  $field_name = $field['field_name'];

  if (empty($_GET[$field_name]) || !is_string($_GET[$field_name])) {
    return $items;
  }

  if (empty($instance['settings']['behaviors']['prepopulate']['status'])) {
    return $items;
  }

  $ids = explode(',', $_GET[$field_name]);
  // Check access to the provided entities.
  $target_type = $field['settings']['target_type'];
  entity_load($target_type, $ids);
  // Remove group nodes hidden by the node access system.

  foreach ($ids as $target_id) {
    $target = entity_load_single($target_type, $target_id);
    if (entity_access('view', $target_type, $target)
      && og_is_group_type($target_type, $target->type)
      && (og_user_access($target_type, $target_id, "create $entity->type content") || og_user_access($target_type, $target_id, "update any $entity->type content"))) {
        $items[] = array('target_id' => $target_id);
    }
  }
  return $items;
}

/**
 * Implements hook_strongarm_alter().
 */
 function commons_groups_strongarm_alter(&$items) {
  // Expose the Group content type for integration with Commons Radioactivity.
  if (isset($items['commons_radioactivity_entity_types'])) {
    $items['commons_radioactivity_entity_types']->value['node']['group'] = 1;
  }
}

function commons_groups_default_rules_configuration_alter(&$configs) {
  // Disable default OG new content notifications.
  // The language doesn't correspond to Commons' open groups model and we use
  // commons_follow and commons_follow_notify for new content notifications.
  if (isset($configs['rules_og_member_active'])) {
    $configs['rules_og_member_active']->active = FALSE;
  }
}

/**
 * Implements hook_node_update().
 */
function commons_groups_node_update($node) {
  $account = user_load($node->uid);
  commons_groups_first_contribution($account, $node);
}

/**
 * Implements hook_node_insert().
 */
function commons_groups_node_insert($node) {
  $account = user_load($node->uid);
  commons_groups_first_contribution($account, $node);
}

/**
 * Returns an array of entity types that are enabled via Commons Groups.
 */
function commons_groups_get_group_content_entity_types() {
  // Find all Commons Entity integrations.
  $commons_entity_integrations = module_invoke_all('commons_entity_integration');
  if (empty($commons_entity_integrations)) {
    return array();
  }

  foreach ($commons_entity_integrations as $entity_type => $integration) {
    foreach ($integration as $bundle => $options) {
      if (isset($options['is_group_content']) && $options['is_group_content'] == FALSE) {
        unset($commons_entity_integrations[$entity_type][$bundle]);
      }
    }
    // If an entity type has no integrations, don't return it.
    if (empty($commons_entity_integrations[$entity_type])) {
      unset($commons_entity_integrations[$entity_type]);
    }
  }

  return $commons_entity_integrations;

}

/**
 * When a user first creates content within a group,
 * grant her the contributor role within that group.
 */
function commons_groups_first_contribution($account, $node) {
  // Find the groups that this piece of content belongs to.
  $groups = og_get_entity_groups('node', $node);
  // @todo: Make it work also with user-groups.
  if (!empty($groups['node'])) {
    $node_groups = array_values($groups['node']);
    // Find the groups that the node author belongs to.
    $account_groups = og_get_groups_by_user($account, 'node');
    if (!$account_groups) {
      $account_groups = array();
    }
    // For groups where this user is not already a member, add her to the group.
    // Anonymous users should never be added to a group automatically
    if ($account->uid == 0) {
      return;
    }
    $new_groups = array_diff($node_groups, $account_groups);
    if (!empty($new_groups)) {
      foreach ($new_groups as $new_group_nid) {
         og_group('node', $new_group_nid, array('entity' => $account->uid));
      }
    }
  }
}

/**
 * Implements hook_commons_bw_group_widget().
 */
function commons_groups_commons_bw_group_widget() {
  return array(
    'commons_all' => array(
      'title' => 'All',
      'type' => 'view',
      'vid' => 'commons_bw_all',
      'display' => 'default',
      'weight' => -10,
      'default' => 1,
    ),
  );
}

/**
 * Implements hook_preprocess_views_view_grid().
 */
function commons_groups_preprocess_views_view_grid(&$variables, $hook) {
  // Change the displayed role name in the group contributors block to
  // "Organizers".
  if ($variables['view']->name == 'commons_contributors_group' && !empty($variables['title']) && $variables['title'] == 'administrator member') {
    $variables['title'] = t('Organizers');
  }
}


/**
 * Implement hook_field_formatter_info().
 */
function commons_groups_field_formatter_info() {
  return array(
    'trusted_contact' => array(
      'label' => t('Trusted Contact'),
      'field types' => array('list_boolean'),
      'settings' => array(
        'field_name' => FALSE,
      ),
    ),
    'approve_ignore' => array(
      'label' => t('Approve Ignore'),
      'field types' => array('text'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function commons_groups_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  global $user;

  $settings = $display['settings'];

  switch ($display['type']) {
    case 'trusted_contact':
      $account = clone $user;
      if (!og_is_group($entity_type, $entity)) {
        return;
      }

      if (!empty($entity->uid) && ($entity->uid == $account->uid)) {
        // User is the group manager.
        return;
      }

      list($id,, $bundle) = entity_extract_ids($entity_type, $entity);
      if (og_is_member($entity_type, $id, 'user', $account, array(OG_STATE_ACTIVE))) {
        $links['title'] = t('Message');
        $links['href'] = "contacts/messages/popup/$id";
      }
      else
        if (og_is_member($entity_type, $id, 'user', $account, array(OG_STATE_PENDING))) {
          // If user is pending, they should not be able to apply for
          // membership.
          $element[0] = array(
            '#markup' => '<div class="trusted-request-pending">' . t('Pending Contact') . '</div>',
          );
          return $element;
        }
        else {
          if (og_is_member($entity_type, $id, 'user', $account, array(OG_STATE_BLOCKED))) {
            // If user is blocked, they should not be able to apply for
            // membership.
            return;
          }

          // Check if user can subscribe to the field.
          if (empty($settings['field_name']) && $audience_field_name = og_get_best_group_audience_field('user', $account, $entity_type, $bundle)) {
            $settings['field_name'] = $audience_field_name;
          }
          if (!$settings['field_name']) {
            return;
          }

          $field_info = field_info_field($settings['field_name']);

          // Check if entity is referencable.
          if ($field_info['settings']['target_type'] != $entity_type) {
            // Group type doesn't match.
            return;
          }
          if (!empty($field_info['settings']['handler_settings']['target_bundles']) && !in_array($bundle, $field_info['settings']['handler_settings']['target_bundles'])) {
            // Bundles don't match.
            return;
          }

          if (!og_check_field_cardinality('user', $account, $settings['field_name'])) {
            // @todo: Is there a limit?
            $element[0] = array('#markup' => format_plural($field_info['cardinality'], 'You are already registered to another group', 'You are already registered to @count groups'));
            return $element;
          }

          $token = drupal_get_token('request' . ':' . $id . ':' . $account->uid);
          $url = "request-trust/$id/$token/nojs";

          $links['title'] = t('Trusted Contact');
          if ($account->uid) {
            $links['href'] = $url;
            $links['options'] = array('attributes' => array('class' => array('use-ajax')));
          }
          else {
            // @todo: Is this ok?
            $links['href'] = 'user/login';
            $links['options'] = array('query' => array('destination' => $url));
          }
        }

      if (!empty($links['title'])) {
        $links += array('options' => array());
        $element[0] = array(
          '#type' => 'link',
          '#title' => $links['title'],
          '#href' => $links['href'],
          '#options' => $links['options'],
        );
        return $element;
      }
      // User didn't have permissions.
      break;

    case 'approve_ignore':

      $approve = l(t('Approve'), 'approve-trust/' . $entity->id . '/' . $items[0]['value']);
      $ignore = l(t('Ignore'), 'ignore-trust/' . $entity->id . '/' . $items[0]['value']);

      $element[0] = array(
        '#markup' =>  "$approve $ignore",
      );
      return $element;

      break;
  }
}

/**
 * Implements hook_og_membership_insert().
 */
function commons_groups_og_membership_insert(OgMembership $og_membership) {
  if ($og_membership->type != 'trusted_contacts' || $og_membership->group_type != 'user') {
    // Not a Trusted-Contact membership type.
    return;
  }

  if (!empty($og_membership->_skip_membership_insert)) {
    // Prevent recursion.
    return;
  }

  // We're using a custom token because Drupal provides a token that relies on
  // logged-in user, and here we want the token to be used by the responding
  // user when approving/ignoring the logged-in user's request.
  $token = md5(rand(100000000, 9999999999));

  $wrapper = entity_metadata_wrapper('og_membership', $og_membership);
  $wrapper->field_my_request->set(1);
  $wrapper->field_membership_token->set($token);

  $values = array(
    'entity' => $og_membership->gid,
    'field_name' => 'user_trusted_contacts',
    'state' => $og_membership->state,
  );

  // Get a non-saved OG Membership object.
  $og_membership2 = og_group('user', $og_membership->etid, $values, FALSE);

  $wrapper2 = entity_metadata_wrapper('og_membership', $og_membership2);
  $wrapper2->field_original_og_membership->set($og_membership);
  $wrapper2->field_my_request->set(0);
  $wrapper2->field_membership_token->set($token);

  // Prevent recursion.
  $og_membership2->_skip_membership_insert = TRUE;
  $wrapper2->save();


  // Make sure OG membership is updated, and not re-inserted.
  unset($og_membership->is_new);

  $wrapper->save();
}

/**
 * Implements hook_og_membership_update().
 */
function commons_groups_og_membership_update(OgMembership $og_membership) {
  if ($og_membership->type != 'trusted_contacts' || $og_membership->group_type != 'user') {
    // Not a Trusted-Contact membership type.
    return;
  }

  if (!empty($og_membership->_skip_membership_update)) {
    // Prevent recursion.
    return;
  }

  $wrapper = entity_metadata_wrapper('og_membership', $og_membership);

  $wrapper_original = entity_metadata_wrapper('og_membership', $og_membership->original);

  // Set the second OG Membership according to the first one.
  // As we are referencing the requesting user to the requested user, we want to
  // keep everything synced.
  $query = new EntityFieldQuery();
  $return = $query
    ->entityCondition('entity_type', 'og_membership')
    ->propertyCondition('group_type', 'user')
    ->propertyCondition('entity_type', 'user')
    ->propertyCondition('etid', $og_membership->gid)
    ->propertyCondition('gid', $og_membership->etid)
    ->execute();

  $membership_id = key($return['og_membership']);

  $wrapper2 = entity_metadata_wrapper('og_membership', $membership_id);
  $og_membership2 = $wrapper2->value();

  if ($wrapper->state->value() != $wrapper_original->state->value()) {
    // State was changed.
    $wrapper2->state->set($wrapper->state->value());

    if ($wrapper_original->state->value() == OG_STATE_PENDING) {
      // Responding to a Trusted-Contact request.
      $confirmation = $wrapper->state->value() == OG_STATE_ACTIVE;
      $wrapper->field_confirmation->set($confirmation);
      $wrapper->field_response_date->set(time());

      // Prevent recursion.
      $og_membership->_skip_membership_update = TRUE;
      $wrapper->save();
    }
  }

  if ($wrapper->field_confirmation->value() != $wrapper_original->field_confirmation->value()) {
    // Confirmation was changed.
    $wrapper2->field_confirmation->set($wrapper->field_confirmation->value());
  }

  if ($wrapper->field_response_date->value() != $wrapper_original->field_response_date->value()) {
    // Response Date was changed.
    $wrapper2->field_response_date->set($wrapper->field_response_date->value());
  }

  // Prevent recursion.
  $og_membership2->_skip_membership_update = TRUE;
  $wrapper2->save();
}

/**
 * Implements hook_og_membership_delete().
 */
function commons_groups_og_membership_delete(OgMembership $og_membership, $type) {
  if ($og_membership->type != 'trusted_contacts' || $og_membership->group_type != 'user') {
    // Not a Trusted-Contact membership type.
    return;
  }

  if (!og_is_member('user', $og_membership->etid, 'user', $og_membership->gid)) {
    // Prevent recursion.
    return;
  }

  // Delete the "opposite" OG membership too.
  og_ungroup('user', $og_membership->etid, 'user', $og_membership->gid);
}

/**
 * Menu callback; Creates a Trusted-Contact Invitation by adding two users to
 * each-other's groups, and setting the memberships' states to 'Pending'.
 *
 * @param $account
 *    The group in which the logged-in user wants to join.
 */
function commons_groups_request_trust($account, $ajax) {
  global $user;

  if ($account->uid == $user->uid) {
    // Users cannot join their own group.
    return;
  }

  // This actually adds 2 OG memberships - one for each user.
  $og_membership = og_group('user', $account, array('field_name' => 'user_trusted_contacts' ,'state' => OG_STATE_PENDING));

  // Notify.

  $wrapper = entity_metadata_wrapper('og_membership', $og_membership);
  $token = $wrapper->field_membership_token->value();

  $arguments = array(
    '@{approve-url}' => 'approve-trust/' . $og_membership->id . '/' . $token,
    '@{ignore-url}' => 'ignore-trust/' . $og_membership->id . '/' . $token,
  );
  $message = message_create('trusted_contact_request_pending', array('uid' => $account->uid, 'arguments' => $arguments));

  $wrapper = entity_metadata_wrapper('message', $message);
  $wrapper->field_requesting_user->set($user);
  $wrapper->save();

  message_notify_send_message($message);

  // Ajax

  if ($ajax == 'ajax') {
    $commands = array();
    $commands[] = ajax_command_replace(".field-name-group-group a", '<div class="trusted-request-pending">' . t('Pending Contact') . '</div>');
    $page = array('#type' => 'ajax', '#commands' => $commands);
    ajax_deliver($page);
  }
  else {
    drupal_goto('user/' . $og_membership->gid);
  }
}

/**
 * Menu callback; "Breaks" a Trusted-Contact relation between two users by
 * ungrouping each of them from the other's group.
 *
 * @param $account
 *    The account which the logged-in user wants to break contact with.
 */
function commons_groups_un_trust($account, $ajax) {
  global $user;

  // This actually deletes 2 OG memberships, one for each user,
  // in commons_groups_og_membership_delete().
  og_ungroup('user', $account->uid);

  // Ajax

  if ($ajax == 'ajax') {
    $token = drupal_get_token('request' . ':' . $account->uid . ':' . $user->uid);
    $new = l(t('Trusted Contact'), 'request-trust/'. $account->uid . '/' . $token . '/nojs', array('attributes' => array('class' => array('use-ajax'))));

    $commands = array();
    $commands[] = ajax_command_replace(".field-name-group-group a", $new);
    $page = array('#type' => 'ajax', '#commands' => $commands);
    ajax_deliver($page);
  }
  else {
    drupal_goto('user/' . $account->uid);
  }
}

/**
 * Menu callback; Approving a Trusted-Contact Invitation by setting each user's
 * membership state to 'Active'.
 *
 * @param $og_membership
 *    The membership in which the logged-in user is the group and the requesting
 *    user is the member.
 */
function commons_groups_approve_trust(OgMembership $og_membership) {
  global $user;

  if ($og_membership->gid != $user->uid) {
    // Users can only approve their requests.
    return;
  }

  // This actually changes both OG memberships - one for each user.
  $wrapper = entity_metadata_wrapper('og_membership', $og_membership);
  $wrapper->state->set(OG_STATE_ACTIVE);
  $wrapper->save();

  // Notify.

  // Get approving user.
  $account = user_load($og_membership->gid);

  $message = message_create('trusted_contact_request_approved', array('uid' => $account->uid));

  $wrapper = entity_metadata_wrapper('message', $message);
  $wrapper->field_approving_user->set($account);
  $wrapper->save();

  message_notify_send_message($message);

  // Redirect to Invitations screen.
  drupal_goto('contacts/invitations');
}

/**
 * Menu callback; Ignoring a Trusted-Contact Invitation by setting each user's
 * membership state to 'Blocked'.
 *
 * @param $og_membership
 *    The membership in which the logged-in user is the group and the requesting
 *    user is the member.
 */
function commons_groups_ignore_trust(OgMembership $og_membership) {
  global $user;

  if ($og_membership->gid != $user->uid) {
    // Users can only ignore their requests.
    return;
  }

  // This actually changes both OG memberships - one for each user.
  $wrapper = entity_metadata_wrapper('og_membership', $og_membership);
  $wrapper->state->set(OG_STATE_BLOCKED);
  $wrapper->save();

  // Redirect to Invitations screen.
  drupal_goto('contacts/invitations');
}

/**
 * Access callback for creating a Trusted-Contact request; Makes sure that the
 * token is correct.
 *
 * @param $account
 *    The group in which the logged-in user wants to join.
 */
function commons_groups_request_trust_access($account, $token) {
  global $user;

  return drupal_valid_token($token, 'request' . ':' . $account->uid . ':' . $user->uid);
}

/**
 * Access callback for breaking a Trusted-Contact relation; Makes sure that the
 * token is correct.
 *
 * @param $account
 *    The account which the logged-in user wants to break contact with.
 */
function commons_groups_un_trust_access($account, $token) {
  global $user;

  return drupal_valid_token($token, 'untrust' . ':' . $account->uid . ':' . $user->uid);
}

/**
 * Access callback for approving an invitation; Makes sure that the token is
 * correct.
 *
 * @param $og_membership
 *    The membership in which the logged-in user is the group and the requesting
 *    user is the member.
 */
function commons_groups_approve_trust_access(OgMembership $og_membership, $token) {
  $wrapper = entity_metadata_wrapper('og_membership', $og_membership);

  return ($wrapper->field_membership_token->value() == $token);
}

/**
 * Access callback for ignoring an invitation; Makes sure that the token is
 * correct.
 *
 * @param $og_membership
 *    The membership in which the logged-in user is the group and the requesting
 *    user is the member.
 */
function commons_groups_ignore_trust_access(OgMembership $og_membership, $token) {
  $wrapper = entity_metadata_wrapper('og_membership', $og_membership);

  return ($wrapper->field_membership_token->value() == $token);
}

/**
 * Returns whether or not two users are trusted contacts.
 *
 * @param $uid
 *    User ID.
 *
 * @param $account
 *    Optional; Other user's object. If not provided, current user will be used.
 */
function commons_group_is_trusted_contact($uid, $account = NULL) {
  if (empty($account)) {
    global $user;
    $account = $user;
  }

  return og_is_member('user', $uid, 'user', $account, array(OG_STATE_ACTIVE));
}

/**
 * Access callback for writing a private message to another user;
 * Checks permissions and makes sure that the given user and the logged-in user
 * are Trusted-Contacts.
 *
 * @param $uid
 *    Addressee's User ID.
 */
function commons_groups_privatemsg_write_access($uid) {
  global $user;

  if ($user->uid == 1) {
    // Always allow admin to send private messages.
    return true;
  }

  return (privatemsg_user_access('write privatemsg') && commons_group_is_trusted_contact($uid));
}

/**
 * Implement hook_form_FORM_alter().
 */
function commons_groups_form_privatemsg_new_alter(&$form, &$form_state) {
  $form['body']['#type'] = 'plain_text';
}

/**
 * Implements hook_action_info().
 *
 * @see views_bulk_operations_action_info()
 */
function commons_groups_action_info() {
  $actions = array();
  $files = commons_groups_operations_load_action_includes();
  foreach ($files as $filename) {
    $action_info_fn = 'commons_groups_'. str_replace('.', '_', basename($filename, '.inc')).'_info';
    $action_info = call_user_func($action_info_fn);
    if (is_array($action_info)) {
      $actions += $action_info;
    }
  }

  return $actions;
}

/**
 * Loads the VBO actions placed in their own include files.
 *
 * @return
 *   An array of containing filenames of the included actions.
 *
 * @see views_bulk_operations_load_action_includes()
 */
function commons_groups_operations_load_action_includes() {
  static $loaded = FALSE;

  $path = drupal_get_path('module', 'commons_groups') . '/includes/actions/';
  $files = array(
    'set_state_active.action.inc',
    'set_state_blocked.action.inc',
    'mark_as_read.action.inc',
  );

  if (!$loaded) {
    foreach ($files as $file) {
      include_once $path . $file;
    }
    $loaded = TRUE;
  }

  return $files;
}

/**
 * Menu callback; Write Private Message popup form.
 *
 * @param $account
 *    The addressee's account.
 */
function commons_groups_messages_popup($form, &$form_state, $account) {
  $wrapper = entity_metadata_wrapper('user', $account);
  $picture_path = empty($account->picture) ? variable_get('user_picture_default') : $wrapper->value()->picture->uri;

  $form['user_picture'] = array(
    '#theme' => 'image_style',
    '#style_name' => '50x50_avatar',
    '#path' => $picture_path,
    '#prefix' => '<div class="user-picture">',
    '#suffix' => '</div>',
  );

  $form['body'] = array(
    '#type' => 'textarea',
    '#rows' => 6,
  );

  $form['actions'] = array('#type' => 'actions');

  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Send'),
  );

  $form['actions']['full_form'] = array(
    '#type' => 'markup',
    '#markup' => l(t('Go to full form'), 'messages/new/' . $account->uid),
  );

  return $form;
}
